{"version":3,"file":"AutoPacker.worker-CK0h2HSz.js","sources":["../node_modules/rectangle-packer/dist/esm/rectanglePacker.js","../node_modules/rectangle-packer/dist/esm/Rect.js","../node_modules/rectangle-packer/dist/esm/GuillotineBinPack.js","../src/workers/AutoPacker.worker.ts"],"sourcesContent":["const SUCCESS = 1;\nconst FAIL = 0;\n/**\n * 放置状态枚举\n */\nvar TheState;\n(function (TheState) {\n    TheState[TheState[\"DO_PLACING\"] = 0] = \"DO_PLACING\";\n    TheState[TheState[\"DEC_WIDTH\"] = 1] = \"DEC_WIDTH\";\n    TheState[TheState[\"INC_HEIGHT\"] = 2] = \"INC_HEIGHT\";\n    TheState[TheState[\"STOP\"] = 3] = \"STOP\";\n})(TheState || (TheState = {}));\n// 未使用的排序函数，可以删除或实现排序逻辑\n// function sortForAreaOrHeight(ar: RectangleSize, br: RectangleSize) {\n//     const a = ar.width * ar.height;\n//     const b = br.width * br.height;\n//     if (a < b) {\n//         return 1;\n//     } else if (a > b) {\n//         return -1;\n//     } else if (ar.height > br.height) {\n//         return -1;\n//     } else if (ar.height < br.height) {\n//         return 1;\n//     } else {\n//         return 0;\n//     }\n// }\n/**\n * 创建 Placing\n * @param enclosingWidth 区域宽\n * @param enclosingHeight 区域高\n */\nfunction allocPlacing(enclosingWidth, enclosingHeight) {\n    const cell = {\n        height: enclosingHeight,\n        occupied: 0,\n        nextCell: null,\n    };\n    const cols = {\n        width: enclosingWidth,\n        nextCol: null,\n        cell,\n    };\n    const placing = {\n        enclosingWidth,\n        enclosingHeight,\n        cols,\n    };\n    return placing;\n}\n/**\n * 释放 Placing 对象\n * @param placing 即将释放的 Placing\n */\nfunction freePlacing(placing) {\n    if (!placing) {\n        return;\n    }\n    // 循环释放列和单元格\n    let col = placing.cols;\n    while (col !== null) {\n        // 释放列中所有单元格\n        let cell = col.cell;\n        while (cell !== null) {\n            const tempR = cell;\n            cell = cell.nextCell;\n            tempR.nextCell = null;\n        }\n        // 保存下一个列，释放当前列\n        const tempC = col;\n        col = col.nextCol;\n        tempC.nextCol = null;\n        tempC.cell = null;\n    }\n    placing.cols = null;\n}\n/**\n * 尝试调整列高度\n * @param col 列\n * @param height 高度\n * @param cellR 区域\n */\nfunction tryFitHeightInCol(col, height, cellR) {\n    /**\n     * 循环列中的单元格\n     * 查找高度大于 height 的连续未被占用的单元格序列。\n     * 结果存储在 cellR 中\n     */\n    if (col == null) {\n        console.error('Error. col pointer was null.\\n');\n        return FAIL;\n    }\n    else if (height <= 0) {\n        console.error('Error. height must be positive.\\n');\n        return FAIL;\n    }\n    let sumHeight = 0;\n    cellR.startIndex = 0;\n    // 循环列中的单元格\n    for (let cell = col.cell, i = 0; cell != null; cell = cell.nextCell, i++) {\n        /**\n         * 如果单元格被占用, 重置高度总和并且更新 startIndex\n         * 否则, 检查高度是否可满足\n         */\n        if (cell.occupied) {\n            sumHeight = 0;\n            cellR.startIndex = i + 1;\n        }\n        else {\n            if (sumHeight + cell.height > height) {\n                cellR.endIndex = i;\n                cellR.overshoot = height - sumHeight;\n                return SUCCESS;\n            }\n            else if (sumHeight + cell.height === height) {\n                // 无需拆分\n                cellR.endIndex = i;\n                cellR.overshoot = 0;\n                return SUCCESS;\n            }\n            sumHeight += cell.height;\n        }\n    }\n    // 如果循环到达这里，说明矩形不适合此列\n    return FAIL;\n}\n/**\n * 查找符合偏移的单元格\n * @param base 基础单元格\n * @param offset 偏移量\n */\nfunction stepOffset(base, offset) {\n    if (base == null) {\n        console.error('Error. Basepointer was null.\\n');\n        return null;\n    }\n    let cell = base;\n    for (let i = 0; i < offset; i++) {\n        cell = cell.nextCell;\n        if (cell == null) {\n            console.error('Error. Offset to large.\\n');\n            return null;\n        }\n    }\n    return cell;\n}\n/**\n * 查找可容纳矩形的区域\n * @param placing 区域\n * @param rectangle 矩形\n * @param reg 位置\n */\nfunction findRegion(placing, rectangle, reg) {\n    // 遍历所有列\n    for (let col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        const colR = {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        };\n        const cellR = {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        };\n        let sumWidth = 0;\n        let temp;\n        // 检查此列是否适合矩形的高度\n        if (!tryFitHeightInCol(col, rectangle.height, cellR)) {\n            // 不合适\n            continue;\n        }\n        // 循环输入列，并检查i的单元格在整个矩形宽度上是否为空\n        colR.startIndex = i;\n        colR.endIndex = i;\n        for (temp = col; temp != null; temp = temp.nextCol) {\n            const cell = stepOffset(temp.cell, cellR.startIndex);\n            if (cell === null || cell === void 0 ? void 0 : cell.occupied) {\n                // 不合适，无法放置\n                break;\n            }\n            else {\n                if (sumWidth + temp.width > rectangle.width) {\n                    // 需要拆分单元格\n                    colR.overshoot = rectangle.width - sumWidth;\n                    reg.colR = colR;\n                    reg.cellR = cellR;\n                    return SUCCESS;\n                }\n                else if (sumWidth + temp.width === rectangle.width) {\n                    // 不需要拆分单元格\n                    colR.overshoot = 0;\n                    reg.colR = colR;\n                    reg.cellR = cellR;\n                    return SUCCESS;\n                }\n                sumWidth += temp.width;\n                colR.endIndex++;\n            }\n        }\n    }\n    return FAIL;\n}\nfunction split(placing, reg) {\n    let colSplitMe = null;\n    // 水平拆分单元格\n    for (let col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        // 仅 overshoot > 0 时才拆分列\n        if (reg.cellR.overshoot > 0) {\n            const cell = stepOffset(col.cell, reg.cellR.endIndex);\n            if (cell == null)\n                continue;\n            const newCell = {\n                // 设置新的单元格\n                height: cell.height - reg.cellR.overshoot,\n                occupied: cell.occupied,\n                nextCell: cell.nextCell,\n            };\n            // 更新旧的单元格\n            cell.height = reg.cellR.overshoot;\n            cell.nextCell = newCell;\n        }\n        // 保存要拆分的列\n        if (i === reg.colR.endIndex) {\n            colSplitMe = col;\n        }\n    }\n    // 仅 overshoot > 0 时才拆分列\n    if (reg.colR.overshoot > 0) {\n        // 纵向拆分列\n        if (colSplitMe == null) {\n            console.log('Error. Failed to find column to split.\\n');\n            return FAIL;\n        }\n        const newCol = {\n            width: colSplitMe.width - reg.colR.overshoot,\n            nextCol: null,\n            cell: {\n                height: 0,\n                occupied: 0,\n                nextCell: null,\n            },\n        };\n        // 设置一个新列\n        let tail = newCol.cell;\n        for (let cell = colSplitMe.cell; cell != null; cell = cell.nextCell) {\n            tail.height = cell.height;\n            tail.occupied = cell.occupied;\n            if (cell.nextCell == null) {\n                tail.nextCell = null;\n                break;\n            }\n            tail.nextCell = {\n                height: 0,\n                occupied: 0,\n                nextCell: null,\n            };\n            tail = tail.nextCell;\n        }\n        newCol.nextCol = colSplitMe.nextCol;\n        // 更新旧的列\n        colSplitMe.width = reg.colR.overshoot;\n        colSplitMe.nextCol = newCol;\n    }\n    return SUCCESS;\n}\n/**\n * 更新单元格，使其放置在正确的位置\n * @param placing 放置区域\n * @param rectangle 矩形\n * @param reg Region\n */\nfunction update(placing, rectangle, reg) {\n    if (!rectangle.__id || rectangle.__id === 0) {\n        console.error(`Error. Rectangle can't have id = ${rectangle.__id}.\\n`);\n        return FAIL;\n    }\n    let x = 0;\n    let y = 0;\n    let done = 0;\n    // 遍历每一列\n    for (let col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        if (i > reg.colR.endIndex) {\n            break;\n        }\n        if (i >= reg.colR.startIndex) {\n            // 遍历单元格\n            for (let cell = col.cell, k = 0; cell != null; cell = cell.nextCell, k++) {\n                if (k > reg.cellR.endIndex) {\n                    break;\n                }\n                if (k >= reg.cellR.startIndex) {\n                    cell.occupied = rectangle.__id;\n                    if (!done) {\n                        rectangle.x = x;\n                        rectangle.y = y;\n                        done = 1;\n                    }\n                }\n                y += cell.height;\n            }\n        }\n        x += col.width;\n    }\n    return SUCCESS;\n}\nfunction addRec(p, r) {\n    const reg = {\n        colR: {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        },\n        cellR: {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        },\n    };\n    if (findRegion(p, r, reg) === FAIL) {\n        return FAIL;\n    }\n    if (split(p, reg) === FAIL) {\n        console.error('Error in splitting.\\n');\n        return FAIL;\n    }\n    if (update(p, r, reg) === FAIL) {\n        console.error('Error in updating.\\n');\n        return FAIL;\n    }\n    return SUCCESS;\n}\n/**\n * 尝试执行内容排列\n * @param list 矩形列表\n * @param enclosingWidth 容器宽度\n * @param enclosingHeight 容器高度\n */\nfunction doPlacing(list, enclosingWidth, enclosingHeight) {\n    let p = allocPlacing(enclosingWidth, enclosingHeight);\n    const len = list.length;\n    for (let i = 0; i < len; i++) {\n        if (!addRec(p, list[i])) {\n            freePlacing(p);\n            p = null;\n            return FAIL;\n        }\n    }\n    freePlacing(p);\n    p = null;\n    return SUCCESS;\n}\n/**\n * 计算所有矩形的宽高和\n * @param list 矩形列表\n */\nfunction sumWH(list) {\n    return list.reduce((acc, rect) => ({\n        width: acc.width + rect.width,\n        height: acc.height + rect.height,\n    }), { width: 0, height: 0 });\n}\n/**\n * 查找所有矩形中，宽度最大值与高度最大值\n * @param list 矩形列表\n */\nfunction maxWH(list) {\n    return list.reduce((acc, rect) => ({\n        width: Math.max(acc.width, rect.width),\n        height: Math.max(acc.height, rect.height),\n    }), { width: 0, height: 0 });\n}\n/**\n * 计算所有矩形总面积\n * @param list 矩形列表\n */\nfunction totalArea(list) {\n    return list.reduce((area, rect) => area + rect.height * rect.width, 0);\n}\n/**\n * 计算容器需要的最大宽度\n * @param list 矩形列表\n */\nfunction placingWidth(list) {\n    let width = 0;\n    for (const rect of list) {\n        if (rect.x === undefined || rect.x === -1) {\n            console.error(\"Error. Can't compute placing_width if not all rectangles have been placed.\\n\");\n            return -1;\n        }\n        const rectRight = rect.width + rect.x;\n        if (rectRight > width) {\n            width = rectRight;\n        }\n    }\n    return width;\n}\n/**\n * 放置最小区域算法\n * @param list 矩形列表\n * @param en 初始区域\n */\nfunction areapackAlgorithm(list, en) {\n    const { width: maxWidth, height: maxHeight } = maxWH(list);\n    const { width: sumWidth } = sumWH(list);\n    let minWidth = -1;\n    let minHeight = -1;\n    let area = -1;\n    let status;\n    let state;\n    const totArea = totalArea(list);\n    /* 初始化高度为最大高度 */\n    en.height = maxHeight;\n    en.width = sumWidth;\n    area = en.height * en.width;\n    state = TheState.DO_PLACING;\n    /* 从封闭区域(w=sum, h=max)开始查找\n     * do placing\n     * - 如果成功，保存区域\n     * - 如果失败，尝试新的封闭区域\n     *\n     * 减小宽度，否则增加高度直到成功\n     *\n     * 如果 en width=max: 停止\n     *\n     * */\n    let loop = 1;\n    while (loop) {\n        switch (state) {\n            case TheState.DO_PLACING:\n                /**\n                 * 尝试将矩形放置在封闭矩形中。\n                 * 如果成功，保存该区域，然后尝试减小包装宽度。\n                 * 如果失败，增加高度并重试。\n                 */\n                status = doPlacing(list, en.width, en.height);\n                if (status === 1) {\n                    en.width = placingWidth(list);\n                    area = en.height * en.width;\n                    minWidth = en.width;\n                    minHeight = en.height;\n                    state = TheState.DEC_WIDTH;\n                }\n                else {\n                    state = TheState.INC_HEIGHT;\n                }\n                break;\n            case TheState.DEC_WIDTH:\n                /**\n                 * 减小包装宽度，然后尝试再次放置。\n                 * 如果新宽度小于矩形的最大宽度，则停止算法并提出最佳解决方案\n                 */\n                en.width--;\n                if (en.width < maxWidth) {\n                    state = TheState.STOP;\n                }\n                else {\n                    state = TheState.DO_PLACING;\n                }\n                break;\n            case TheState.INC_HEIGHT:\n                /**\n                 * 增加封闭高度，然后尝试再次放置。\n                 * 但是，如果新的高度使封闭区域小于所有矩形的总面积，则增加封闭高度并重新开始。\n                 * 如果封闭区域比目前最好的封闭区域大，则减小封闭宽度并重新开始。\n                 */\n                en.height++;\n                if (en.height * en.width < totArea) {\n                    state = TheState.INC_HEIGHT;\n                }\n                else if (en.height * en.width >= area) {\n                    state = TheState.DEC_WIDTH;\n                }\n                else {\n                    state = TheState.DO_PLACING;\n                }\n                break;\n            case TheState.STOP:\n                // 计算结束\n                loop = 0;\n                break;\n        }\n    }\n    if (minWidth === -1 || minHeight === -1) {\n        return FAIL;\n    }\n    // 以最佳的宽度和高度进行最后放置\n    status = doPlacing(list, minWidth, minHeight);\n    return SUCCESS;\n}\n/**\n * 打包给到的所有矩形\n * @param rectangleSizes 带有宽高的矩形列表\n */\nexport function rectanglePacker(rectangleSizes) {\n    if (!Array.isArray(rectangleSizes) || rectangleSizes.length === 0)\n        return [];\n    const enclosing = { width: 0, height: 0 };\n    const rectList = rectangleSizes.map(({ width, height }, i) => {\n        if (!width || !height || width <= 0 || height <= 0) {\n            throw new Error(`Rectangle at index ${i} must have positive width and height, got: ${width}x${height}`);\n        }\n        return {\n            width,\n            height,\n            x: -1,\n            y: -1,\n            __id: i + 1,\n        };\n    });\n    const result = areapackAlgorithm(rectList, enclosing);\n    if (result === FAIL) {\n        console.error('Unexpected error in algorithm implementation');\n        return [];\n    }\n    rectList.forEach((rectangle) => {\n        if (rectangle.__id !== undefined) {\n            delete rectangle.__id;\n        }\n    });\n    return rectList;\n}\nexport function rectanglePackerMutation(rectangleSizes) {\n    const list = rectanglePacker(rectangleSizes);\n    rectangleSizes.forEach((rs, i) => {\n        rs.x = list[i].x;\n        rs.y = list[i].y;\n    });\n    return rectangleSizes;\n}\n//# sourceMappingURL=rectanglePacker.js.map","export default class Rect {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    static IsContainedIn(a, b) {\n        return a.x >= b.x && a.y >= b.y && a.x + a.width <= b.x + b.width && a.y + a.height <= b.y + b.height;\n    }\n}\n//# sourceMappingURL=Rect.js.map","import Rect from './Rect.js';\n/// Specifies the different choice heuristics that can be used when deciding which of the free subrectangles\n/// to place the to-be-packed rectangle into.\nvar FreeRectChoiceHeuristic;\n(function (FreeRectChoiceHeuristic) {\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectBestAreaFit\"] = 0] = \"RectBestAreaFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectBestShortSideFit\"] = 1] = \"RectBestShortSideFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectBestLongSideFit\"] = 2] = \"RectBestLongSideFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectWorstAreaFit\"] = 3] = \"RectWorstAreaFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectWorstShortSideFit\"] = 4] = \"RectWorstShortSideFit\";\n    FreeRectChoiceHeuristic[FreeRectChoiceHeuristic[\"RectWorstLongSideFit\"] = 5] = \"RectWorstLongSideFit\";\n})(FreeRectChoiceHeuristic || (FreeRectChoiceHeuristic = {}));\n/// Specifies the different choice heuristics that can be used when the packer needs to decide whether to\n/// subdivide the remaining free space in horizontal or vertical direction.\nvar GuillotineSplitHeuristic;\n(function (GuillotineSplitHeuristic) {\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitShorterLeftoverAxis\"] = 0] = \"SplitShorterLeftoverAxis\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitLongerLeftoverAxis\"] = 1] = \"SplitLongerLeftoverAxis\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitMinimizeArea\"] = 2] = \"SplitMinimizeArea\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitMaximizeArea\"] = 3] = \"SplitMaximizeArea\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitShorterAxis\"] = 4] = \"SplitShorterAxis\";\n    GuillotineSplitHeuristic[GuillotineSplitHeuristic[\"SplitLongerAxis\"] = 5] = \"SplitLongerAxis\";\n})(GuillotineSplitHeuristic || (GuillotineSplitHeuristic = {}));\nclass GuillotineBinPack {\n    constructor(binWidth = 0, binHeight = 0, allowFlip = false) {\n        this.binWidth = binWidth;\n        this.binHeight = binHeight;\n        this.allowFlip = allowFlip;\n        this.usedRectangles = [];\n        this.freeRectangles = [];\n        if (this.binWidth && this.binHeight) {\n            this.freeRectangles.push(new Rect(0, 0, this.binWidth, this.binHeight));\n        }\n    }\n    InsertSizes(rects, merge, rectChoice, splitMethod) {\n        if (!Array.isArray(rects) || rects.length === 0) {\n            return;\n        }\n        // Validate input rectangles\n        for (const rect of rects) {\n            if (!rect || rect.width < 0 || rect.height < 0) {\n                console.error('Invalid rectangle dimensions');\n                return;\n            }\n        }\n        // Remember variables about the best packing choice we have made so far during the iteration process.\n        let bestFreeRect = 0;\n        let bestRect = 0;\n        let bestFlipped = false;\n        // Pack rectangles one at a time until we have cleared the rects array of all rectangles.\n        // rects will get destroyed in the process.\n        while (rects.length > 0) {\n            // Stores the penalty score of the best rectangle placement - bigger=worse, smaller=better.\n            let bestScore = Number.MAX_VALUE;\n            for (let i = 0; i < this.freeRectangles.length; ++i) {\n                for (let j = 0; j < rects.length; ++j) {\n                    // If this rectangle is a perfect match, we pick it instantly.\n                    if (rects[j].width === this.freeRectangles[i].width &&\n                        rects[j].height === this.freeRectangles[i].height) {\n                        bestFreeRect = i;\n                        bestRect = j;\n                        bestFlipped = false;\n                        bestScore = Number.MIN_VALUE;\n                        i = this.freeRectangles.length; // Force a jump out of the outer loop as well - we got an instant fit.\n                        break;\n                    }\n                    // If flipping this rectangle is a perfect match, pick that then.\n                    else if (this.allowFlip &&\n                        rects[j].height === this.freeRectangles[i].width &&\n                        rects[j].width === this.freeRectangles[i].height) {\n                        bestFreeRect = i;\n                        bestRect = j;\n                        bestFlipped = true;\n                        bestScore = Number.MIN_VALUE;\n                        i = this.freeRectangles.length; // Force a jump out of the outer loop as well - we got an instant fit.\n                        break;\n                    }\n                    // Try if we can fit the rectangle upright.\n                    else if (rects[j].width <= this.freeRectangles[i].width &&\n                        rects[j].height <= this.freeRectangles[i].height) {\n                        let score = this.ScoreByHeuristic(rects[j].width, rects[j].height, this.freeRectangles[i], rectChoice);\n                        if (score < bestScore) {\n                            bestFreeRect = i;\n                            bestRect = j;\n                            bestFlipped = false;\n                            bestScore = score;\n                        }\n                    }\n                    // If not, then perhaps flipping sideways will make it fit?\n                    else if (this.allowFlip &&\n                        rects[j].height <= this.freeRectangles[i].width &&\n                        rects[j].width <= this.freeRectangles[i].height) {\n                        let score = this.ScoreByHeuristic(rects[j].height, rects[j].width, this.freeRectangles[i], rectChoice);\n                        if (score < bestScore) {\n                            bestFreeRect = i;\n                            bestRect = j;\n                            bestFlipped = true;\n                            bestScore = score;\n                        }\n                    }\n                }\n            }\n            // If we didn't manage to find any rectangle to pack, abort.\n            if (bestScore === Number.MAX_VALUE)\n                return;\n            // Remove the rectangle we just packed from the input list.\n            const [node] = rects.splice(bestRect, 1);\n            node.x = this.freeRectangles[bestFreeRect].x;\n            node.y = this.freeRectangles[bestFreeRect].y;\n            // Otherwise, we're good to go and do the actual packing.\n            const newNode = new Rect(this.freeRectangles[bestFreeRect].x, this.freeRectangles[bestFreeRect].y, node.width, node.height);\n            if (bestFlipped)\n                [newNode.width, newNode.height] = [newNode.height, newNode.width];\n            // Remove the free space we lost in the bin.\n            this.SplitFreeRectByHeuristic(this.freeRectangles[bestFreeRect], newNode, splitMethod);\n            this.freeRectangles.splice(bestFreeRect, 1);\n            // Perform a Rectangle Merge step if desired.\n            if (merge)\n                this.MergeFreeList();\n            // Remember the new used rectangle.\n            this.usedRectangles.push(node);\n            // Check that we're really producing correct packings here.\n            // debug_assert(disjointRects.Add(newNode) === true);\n        }\n    }\n    /// @return True if r fits inside freeRect (possibly rotated).\n    Fits(r, freeRect) {\n        return ((r.width <= freeRect.width && r.height <= freeRect.height) ||\n            (r.height <= freeRect.width && r.width <= freeRect.height));\n    }\n    /// @return True if r fits perfectly inside freeRect, i.e. the leftover area is 0.\n    FitsPerfectly(r, freeRect) {\n        return ((r.width === freeRect.width && r.height === freeRect.height) ||\n            (r.height === freeRect.width && r.width === freeRect.height));\n    }\n    //   Insert(\n    //     width: number,\n    //     height: number,\n    //     merge: boolean,\n    //     rectChoice: FreeRectChoiceHeuristic,\n    //     splitMethod: GuillotineSplitHeuristic,\n    //   ): Rect {\n    //     // Find where to put the new rectangle.\n    //     let freeNodeIndex: RefNumber = { value: 0 }\n    //     const newRect: Rect = this.FindPositionForNewNode(\n    //       width,\n    //       height,\n    //       rectChoice,\n    //       freeNodeIndex,\n    //     )\n    //     // Abort if we didn't have enough space in the bin.\n    //     if (newRect.height === 0) return newRect\n    //     // Remove the space that was just consumed by the new rectangle.\n    //     this.SplitFreeRectByHeuristic(\n    //       this.freeRectangles[freeNodeIndex.value],\n    //       newRect,\n    //       splitMethod,\n    //     )\n    //     this.freeRectangles.splice(freeNodeIndex.value, 1)\n    //     // Perform a Rectangle Merge step if desired.\n    //     if (merge) this.MergeFreeList()\n    //     // Remember the new used rectangle.\n    //     this.usedRectangles.push(newRect)\n    //     // Check that we're really producing correct packings here.\n    //     // debug_assert(disjointRects.Add(newRect) === true);\n    //     return newRect\n    //   }\n    /// Computes the ratio of used surface area to the total bin area.\n    Occupancy() {\n        const usedSurfaceArea = this.usedRectangles.reduce((area, rect) => area + rect.width * rect.height, 0);\n        return usedSurfaceArea / (this.binWidth * this.binHeight);\n    }\n    /// Returns the heuristic score value for placing a rectangle of size width*height into freeRect. Does not try to rotate.\n    ScoreByHeuristic(width, height, freeRect, rectChoice) {\n        switch (rectChoice) {\n            case FreeRectChoiceHeuristic.RectBestAreaFit:\n                return this.ScoreBestAreaFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectBestShortSideFit:\n                return this.ScoreBestShortSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectBestLongSideFit:\n                return this.ScoreBestLongSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstAreaFit:\n                return this.ScoreWorstAreaFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstShortSideFit:\n                return this.ScoreWorstShortSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstLongSideFit:\n                return this.ScoreWorstLongSideFit(width, height, freeRect);\n            default:\n                return Number.MAX_VALUE;\n        }\n    }\n    ScoreBestAreaFit(width, height, freeRect) {\n        return freeRect.width * freeRect.height - width * height;\n    }\n    ScoreBestShortSideFit(width, height, freeRect) {\n        const leftoverHoriz = Math.abs(freeRect.width - width);\n        const leftoverVert = Math.abs(freeRect.height - height);\n        const leftover = Math.min(leftoverHoriz, leftoverVert);\n        return leftover;\n    }\n    ScoreBestLongSideFit(width, height, freeRect) {\n        const leftoverHoriz = Math.abs(freeRect.width - width);\n        const leftoverVert = Math.abs(freeRect.height - height);\n        const leftover = Math.max(leftoverHoriz, leftoverVert);\n        return leftover;\n    }\n    ScoreWorstAreaFit(width, height, freeRect) {\n        return -this.ScoreBestAreaFit(width, height, freeRect);\n    }\n    ScoreWorstShortSideFit(width, height, freeRect) {\n        return -this.ScoreBestShortSideFit(width, height, freeRect);\n    }\n    ScoreWorstLongSideFit(width, height, freeRect) {\n        return -this.ScoreBestLongSideFit(width, height, freeRect);\n    }\n    FindPositionForNewNode(width, height, rectChoice, nodeIndex) {\n        let bestNode = new Rect();\n        let bestScore = Number.MAX_VALUE;\n        /// Try each free rectangle to find the best one for placement.\n        for (let i = 0; i < this.freeRectangles.length; ++i) {\n            // If this is a perfect fit upright, choose it immediately.\n            if (width === this.freeRectangles[i].width && height === this.freeRectangles[i].height) {\n                bestNode.x = this.freeRectangles[i].x;\n                bestNode.y = this.freeRectangles[i].y;\n                bestNode.width = width;\n                bestNode.height = height;\n                bestScore = Number.MIN_VALUE;\n                nodeIndex.value = i;\n                // debug_assert(disjointRects.Disjoint(bestNode));\n                break;\n            }\n            // If this is a perfect fit sideways, choose it.\n            else if (height === this.freeRectangles[i].width && width === this.freeRectangles[i].height) {\n                bestNode.x = this.freeRectangles[i].x;\n                bestNode.y = this.freeRectangles[i].y;\n                bestNode.width = height;\n                bestNode.height = width;\n                bestScore = Number.MIN_VALUE;\n                nodeIndex.value = i;\n                // debug_assert(disjointRects.Disjoint(bestNode));\n                break;\n            }\n            // Does the rectangle fit upright?\n            else if (width <= this.freeRectangles[i].width && height <= this.freeRectangles[i].height) {\n                let score = this.ScoreByHeuristic(width, height, this.freeRectangles[i], rectChoice);\n                if (score < bestScore) {\n                    bestNode.x = this.freeRectangles[i].x;\n                    bestNode.y = this.freeRectangles[i].y;\n                    bestNode.width = width;\n                    bestNode.height = height;\n                    bestScore = score;\n                    nodeIndex.value = i;\n                    // debug_assert(disjointRects.Disjoint(bestNode));\n                }\n            }\n            // Does the rectangle fit sideways?\n            else if (height <= this.freeRectangles[i].width && width <= this.freeRectangles[i].height) {\n                let score = this.ScoreByHeuristic(height, width, this.freeRectangles[i], rectChoice);\n                if (score < bestScore) {\n                    bestNode.x = this.freeRectangles[i].x;\n                    bestNode.y = this.freeRectangles[i].y;\n                    bestNode.width = height;\n                    bestNode.height = width;\n                    bestScore = score;\n                    nodeIndex.value = i;\n                    // debug_assert(disjointRects.Disjoint(bestNode));\n                }\n            }\n        }\n        return bestNode;\n    }\n    SplitFreeRectByHeuristic(freeRect, placedRect, method) {\n        // Compute the lengths of the leftover area.\n        const w = freeRect.width - placedRect.width;\n        const h = freeRect.height - placedRect.height;\n        // Placing placedRect into freeRect results in an L-shaped free area, which must be split into\n        // two disjoint rectangles. This can be achieved with by splitting the L-shape using a single line.\n        // We have two choices: horizontal or vertical.\n        // Use the given heuristic to decide which choice to make.\n        let splitHorizontal;\n        switch (method) {\n            case GuillotineSplitHeuristic.SplitShorterLeftoverAxis:\n                // Split along the shorter leftover axis.\n                splitHorizontal = w <= h;\n                break;\n            case GuillotineSplitHeuristic.SplitLongerLeftoverAxis:\n                // Split along the longer leftover axis.\n                splitHorizontal = w > h;\n                break;\n            case GuillotineSplitHeuristic.SplitMinimizeArea:\n                // Maximize the larger area === minimize the smaller area.\n                // Tries to make the single bigger rectangle.\n                splitHorizontal = placedRect.width * h > w * placedRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitMaximizeArea:\n                // Maximize the smaller area === minimize the larger area.\n                // Tries to make the rectangles more even-sized.\n                splitHorizontal = placedRect.width * h <= w * placedRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitShorterAxis:\n                // Split along the shorter total axis.\n                splitHorizontal = freeRect.width <= freeRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitLongerAxis:\n                // Split along the longer total axis.\n                splitHorizontal = freeRect.width > freeRect.height;\n                break;\n            default:\n                splitHorizontal = true;\n            // assert(false);\n        }\n        // Perform the actual split.\n        this.SplitFreeRectAlongAxis(freeRect, placedRect, splitHorizontal);\n    }\n    /// This function will add the two generated rectangles into the this.freeRectangles array. The caller is expected to\n    /// remove the original rectangle from the this.freeRectangles array after that.\n    SplitFreeRectAlongAxis(freeRect, placedRect, splitHorizontal) {\n        // Form the two new rectangles.\n        const bottom = new Rect(freeRect.x, freeRect.y + placedRect.height, 0, freeRect.height - placedRect.height);\n        const right = new Rect(freeRect.x + placedRect.width, freeRect.y, freeRect.width - placedRect.width, 0);\n        if (splitHorizontal) {\n            bottom.width = freeRect.width;\n            right.height = placedRect.height;\n        } // Split vertically\n        else {\n            bottom.width = placedRect.width;\n            right.height = freeRect.height;\n        }\n        // Add the new rectangles into the free rectangle pool if they weren't degenerate.\n        if (bottom.width > 0 && bottom.height > 0)\n            this.freeRectangles.push(bottom);\n        if (right.width > 0 && right.height > 0)\n            this.freeRectangles.push(right);\n        // debug_assert(disjointRects.Disjoint(bottom));\n        // debug_assert(disjointRects.Disjoint(right));\n    }\n    MergeFreeList() {\n        // Do a Theta(n^2) loop to see if any pair of free rectangles could me merged into one.\n        // Note that we miss any opportunities to merge three rectangles into one. (should call this function again to detect that)\n        for (let i = 0; i < this.freeRectangles.length; ++i)\n            for (let j = i + 1; j < this.freeRectangles.length; ++j) {\n                if (this.freeRectangles[i].width === this.freeRectangles[j].width &&\n                    this.freeRectangles[i].x === this.freeRectangles[j].x) {\n                    if (this.freeRectangles[i].y === this.freeRectangles[j].y + this.freeRectangles[j].height) {\n                        this.freeRectangles[i].y -= this.freeRectangles[j].height;\n                        this.freeRectangles[i].height += this.freeRectangles[j].height;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                    else if (this.freeRectangles[i].y + this.freeRectangles[i].height === this.freeRectangles[j].y) {\n                        this.freeRectangles[i].height += this.freeRectangles[j].height;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                }\n                else if (this.freeRectangles[i].height === this.freeRectangles[j].height &&\n                    this.freeRectangles[i].y === this.freeRectangles[j].y) {\n                    if (this.freeRectangles[i].x === this.freeRectangles[j].x + this.freeRectangles[j].width) {\n                        this.freeRectangles[i].x -= this.freeRectangles[j].width;\n                        this.freeRectangles[i].width += this.freeRectangles[j].width;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                    else if (this.freeRectangles[i].x + this.freeRectangles[i].width === this.freeRectangles[j].x) {\n                        this.freeRectangles[i].width += this.freeRectangles[j].width;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                }\n            }\n    }\n}\nGuillotineBinPack.FreeRectChoiceHeuristic = FreeRectChoiceHeuristic;\nGuillotineBinPack.GuillotineSplitHeuristic = GuillotineSplitHeuristic;\nexport default GuillotineBinPack;\n//# sourceMappingURL=GuillotineBinPack.js.map","import { GuillotineBinPack } from 'rectangle-packer'\n\ninterface Rectangle {\n  width: number\n  height: number\n  x: number\n  y: number\n  letter: string\n}\n\nfunction maxMin(list: Rectangle[]) {\n  const widthList = list.map((item) => item.width)\n  const heightList = list.map((item) => item.height)\n  return {\n    minWidth: Math.min.apply(null, widthList),\n    minHeight: Math.min.apply(null, heightList),\n    maxWidth: widthList.reduce((a, b) => a + b, 0),\n    maxHeight: heightList.reduce((a, b) => a + b, 0),\n  }\n}\n\nfunction packing(list: Rectangle[]) {\n  const sizes = maxMin(list)\n  let min = Math.max(sizes.minWidth, sizes.minHeight)\n  let max = Math.max(sizes.maxWidth, sizes.maxHeight)\n  let state = 1\n  let placed: Rectangle[] = []\n  while (state) {\n    const size = min + Math.ceil((max - min) / 2)\n    const packer = new GuillotineBinPack<Rectangle>(size, size)\n    packer.InsertSizes([...list], true, 1, 1)\n\n    if (max - min < 2) {\n      state = 0\n    } else if (list.length > packer.usedRectangles.length) {\n      min += Math.ceil((max - min) / 2)\n    } else {\n      placed = packer.usedRectangles\n      max -= Math.floor((max - min) / 2)\n    }\n  }\n  return placed\n}\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = self as unknown as Worker\nctx.addEventListener(\n  'message',\n  function converter(msg) {\n    const { data } = msg\n    if (data.length > 1) {\n      const list = packing(data as Rectangle[])\n      ctx.postMessage(list)\n    } else {\n      ctx.postMessage(data || [])\n    }\n  },\n  false,\n)\n"],"names":["TheState","Rect","x","y","width","height","a","b","FreeRectChoiceHeuristic","GuillotineSplitHeuristic","GuillotineBinPack","binWidth","binHeight","allowFlip","rects","merge","rectChoice","splitMethod","rect","bestFreeRect","bestRect","bestFlipped","bestScore","i","j","score","node","newNode","r","freeRect","area","leftoverHoriz","leftoverVert","nodeIndex","bestNode","placedRect","method","w","h","splitHorizontal","bottom","right","maxMin","list","widthList","item","heightList","packing","sizes","min","max","state","placed","size","packer","ctx","msg","data"],"mappings":"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","x_google_ignoreList":[0,1,2]}