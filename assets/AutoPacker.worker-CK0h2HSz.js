var x;(function(h){h[h.DO_PLACING=0]="DO_PLACING",h[h.DEC_WIDTH=1]="DEC_WIDTH",h[h.INC_HEIGHT=2]="INC_HEIGHT",h[h.STOP=3]="STOP"})(x||(x={}));class R{constructor(e=0,t=0,i=0,n=0){this.x=e,this.y=t,this.width=i,this.height=n}static IsContainedIn(e,t){return e.x>=t.x&&e.y>=t.y&&e.x+e.width<=t.x+t.width&&e.y+e.height<=t.y+t.height}}var f;(function(h){h[h.RectBestAreaFit=0]="RectBestAreaFit",h[h.RectBestShortSideFit=1]="RectBestShortSideFit",h[h.RectBestLongSideFit=2]="RectBestLongSideFit",h[h.RectWorstAreaFit=3]="RectWorstAreaFit",h[h.RectWorstShortSideFit=4]="RectWorstShortSideFit",h[h.RectWorstLongSideFit=5]="RectWorstLongSideFit"})(f||(f={}));var c;(function(h){h[h.SplitShorterLeftoverAxis=0]="SplitShorterLeftoverAxis",h[h.SplitLongerLeftoverAxis=1]="SplitLongerLeftoverAxis",h[h.SplitMinimizeArea=2]="SplitMinimizeArea",h[h.SplitMaximizeArea=3]="SplitMaximizeArea",h[h.SplitShorterAxis=4]="SplitShorterAxis",h[h.SplitLongerAxis=5]="SplitLongerAxis"})(c||(c={}));class u{constructor(e=0,t=0,i=!1){this.binWidth=e,this.binHeight=t,this.allowFlip=i,this.usedRectangles=[],this.freeRectangles=[],this.binWidth&&this.binHeight&&this.freeRectangles.push(new R(0,0,this.binWidth,this.binHeight))}InsertSizes(e,t,i,n){if(!Array.isArray(e)||e.length===0)return;for(const o of e)if(!o||o.width<0||o.height<0){console.error("Invalid rectangle dimensions");return}let s=0,g=0,r=!1;for(;e.length>0;){let o=Number.MAX_VALUE;for(let a=0;a<this.freeRectangles.length;++a)for(let l=0;l<e.length;++l)if(e[l].width===this.freeRectangles[a].width&&e[l].height===this.freeRectangles[a].height){s=a,g=l,r=!1,o=Number.MIN_VALUE,a=this.freeRectangles.length;break}else if(this.allowFlip&&e[l].height===this.freeRectangles[a].width&&e[l].width===this.freeRectangles[a].height){s=a,g=l,r=!0,o=Number.MIN_VALUE,a=this.freeRectangles.length;break}else if(e[l].width<=this.freeRectangles[a].width&&e[l].height<=this.freeRectangles[a].height){let w=this.ScoreByHeuristic(e[l].width,e[l].height,this.freeRectangles[a],i);w<o&&(s=a,g=l,r=!1,o=w)}else if(this.allowFlip&&e[l].height<=this.freeRectangles[a].width&&e[l].width<=this.freeRectangles[a].height){let w=this.ScoreByHeuristic(e[l].height,e[l].width,this.freeRectangles[a],i);w<o&&(s=a,g=l,r=!0,o=w)}if(o===Number.MAX_VALUE)return;const[d]=e.splice(g,1);d.x=this.freeRectangles[s].x,d.y=this.freeRectangles[s].y;const S=new R(this.freeRectangles[s].x,this.freeRectangles[s].y,d.width,d.height);r&&([S.width,S.height]=[S.height,S.width]),this.SplitFreeRectByHeuristic(this.freeRectangles[s],S,n),this.freeRectangles.splice(s,1),t&&this.MergeFreeList(),this.usedRectangles.push(d)}}Fits(e,t){return e.width<=t.width&&e.height<=t.height||e.height<=t.width&&e.width<=t.height}FitsPerfectly(e,t){return e.width===t.width&&e.height===t.height||e.height===t.width&&e.width===t.height}Occupancy(){return this.usedRectangles.reduce((t,i)=>t+i.width*i.height,0)/(this.binWidth*this.binHeight)}ScoreByHeuristic(e,t,i,n){switch(n){case f.RectBestAreaFit:return this.ScoreBestAreaFit(e,t,i);case f.RectBestShortSideFit:return this.ScoreBestShortSideFit(e,t,i);case f.RectBestLongSideFit:return this.ScoreBestLongSideFit(e,t,i);case f.RectWorstAreaFit:return this.ScoreWorstAreaFit(e,t,i);case f.RectWorstShortSideFit:return this.ScoreWorstShortSideFit(e,t,i);case f.RectWorstLongSideFit:return this.ScoreWorstLongSideFit(e,t,i);default:return Number.MAX_VALUE}}ScoreBestAreaFit(e,t,i){return i.width*i.height-e*t}ScoreBestShortSideFit(e,t,i){const n=Math.abs(i.width-e),s=Math.abs(i.height-t);return Math.min(n,s)}ScoreBestLongSideFit(e,t,i){const n=Math.abs(i.width-e),s=Math.abs(i.height-t);return Math.max(n,s)}ScoreWorstAreaFit(e,t,i){return-this.ScoreBestAreaFit(e,t,i)}ScoreWorstShortSideFit(e,t,i){return-this.ScoreBestShortSideFit(e,t,i)}ScoreWorstLongSideFit(e,t,i){return-this.ScoreBestLongSideFit(e,t,i)}FindPositionForNewNode(e,t,i,n){let s=new R,g=Number.MAX_VALUE;for(let r=0;r<this.freeRectangles.length;++r)if(e===this.freeRectangles[r].width&&t===this.freeRectangles[r].height){s.x=this.freeRectangles[r].x,s.y=this.freeRectangles[r].y,s.width=e,s.height=t,g=Number.MIN_VALUE,n.value=r;break}else if(t===this.freeRectangles[r].width&&e===this.freeRectangles[r].height){s.x=this.freeRectangles[r].x,s.y=this.freeRectangles[r].y,s.width=t,s.height=e,g=Number.MIN_VALUE,n.value=r;break}else if(e<=this.freeRectangles[r].width&&t<=this.freeRectangles[r].height){let o=this.ScoreByHeuristic(e,t,this.freeRectangles[r],i);o<g&&(s.x=this.freeRectangles[r].x,s.y=this.freeRectangles[r].y,s.width=e,s.height=t,g=o,n.value=r)}else if(t<=this.freeRectangles[r].width&&e<=this.freeRectangles[r].height){let o=this.ScoreByHeuristic(t,e,this.freeRectangles[r],i);o<g&&(s.x=this.freeRectangles[r].x,s.y=this.freeRectangles[r].y,s.width=t,s.height=e,g=o,n.value=r)}return s}SplitFreeRectByHeuristic(e,t,i){const n=e.width-t.width,s=e.height-t.height;let g;switch(i){case c.SplitShorterLeftoverAxis:g=n<=s;break;case c.SplitLongerLeftoverAxis:g=n>s;break;case c.SplitMinimizeArea:g=t.width*s>n*t.height;break;case c.SplitMaximizeArea:g=t.width*s<=n*t.height;break;case c.SplitShorterAxis:g=e.width<=e.height;break;case c.SplitLongerAxis:g=e.width>e.height;break;default:g=!0}this.SplitFreeRectAlongAxis(e,t,g)}SplitFreeRectAlongAxis(e,t,i){const n=new R(e.x,e.y+t.height,0,e.height-t.height),s=new R(e.x+t.width,e.y,e.width-t.width,0);i?(n.width=e.width,s.height=t.height):(n.width=t.width,s.height=e.height),n.width>0&&n.height>0&&this.freeRectangles.push(n),s.width>0&&s.height>0&&this.freeRectangles.push(s)}MergeFreeList(){for(let e=0;e<this.freeRectangles.length;++e)for(let t=e+1;t<this.freeRectangles.length;++t)this.freeRectangles[e].width===this.freeRectangles[t].width&&this.freeRectangles[e].x===this.freeRectangles[t].x?this.freeRectangles[e].y===this.freeRectangles[t].y+this.freeRectangles[t].height?(this.freeRectangles[e].y-=this.freeRectangles[t].height,this.freeRectangles[e].height+=this.freeRectangles[t].height,this.freeRectangles.splice(t,1),--t):this.freeRectangles[e].y+this.freeRectangles[e].height===this.freeRectangles[t].y&&(this.freeRectangles[e].height+=this.freeRectangles[t].height,this.freeRectangles.splice(t,1),--t):this.freeRectangles[e].height===this.freeRectangles[t].height&&this.freeRectangles[e].y===this.freeRectangles[t].y&&(this.freeRectangles[e].x===this.freeRectangles[t].x+this.freeRectangles[t].width?(this.freeRectangles[e].x-=this.freeRectangles[t].width,this.freeRectangles[e].width+=this.freeRectangles[t].width,this.freeRectangles.splice(t,1),--t):this.freeRectangles[e].x+this.freeRectangles[e].width===this.freeRectangles[t].x&&(this.freeRectangles[e].width+=this.freeRectangles[t].width,this.freeRectangles.splice(t,1),--t))}}u.FreeRectChoiceHeuristic=f;u.GuillotineSplitHeuristic=c;function F(h){const e=h.map(i=>i.width),t=h.map(i=>i.height);return{minWidth:Math.min.apply(null,e),minHeight:Math.min.apply(null,t),maxWidth:e.reduce((i,n)=>i+n,0),maxHeight:t.reduce((i,n)=>i+n,0)}}function y(h){const e=F(h);let t=Math.max(e.minWidth,e.minHeight),i=Math.max(e.maxWidth,e.maxHeight),n=1,s=[];for(;n;){const g=t+Math.ceil((i-t)/2),r=new u(g,g);r.InsertSizes([...h],!0,1,1),i-t<2?n=0:h.length>r.usedRectangles.length?t+=Math.ceil((i-t)/2):(s=r.usedRectangles,i-=Math.floor((i-t)/2))}return s}const A=self;A.addEventListener("message",function(e){const{data:t}=e;if(t.length>1){const i=y(t);A.postMessage(i)}else A.postMessage(t||[])},!1);
//# sourceMappingURL=AutoPacker.worker-CK0h2HSz.js.map
