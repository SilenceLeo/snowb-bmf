import formatStr from 'src/utils/replaceVariables'

import { FontToContent, Output } from '../type'

const TEMP_INFO = `info face="$face$" size=$size$ bold=$bold$ italic=$italic$ charset=$charset$ unicode=$unicode$ stretchH=$stretchH$ smooth=$smooth$ aa=$aa$ padding=$padding$ spacing=$spacing$ outline=$outline$\n`
const TEMP_COMMON = `common lineHeight=$lineHeight$ base=$base$ scaleW=$scaleW$ scaleH=$scaleH$ pages=$pages$ packed=$packed$ alphaChnl=$alphaChnl$ redChnl=$redChnl$ greenChnl=$greenChnl$ blueChnl=$blueChnl$\n`
const TEMP_PAGE = `page id=$id$ file="$file$"\n`
const TEMP_CHARS = `chars count=$count$\n`
const TEMP_CHAR = `char id=$id$ x=$x$ y=$y$ width=$width$ height=$height$ xoffset=$xoffset$ yoffset=$yoffset$ xadvance=$xadvance$ page=$page$ chnl=$chnl$\n`
const TEMP_KERNINGS = `kernings count=$count$\n`
const TEMP_KERNING = `kerning first=$first$ second=$second$ amount=$amount$\n`

const type = 'TEXT'

const exts = ['fnt', 'txt']

const getContent: FontToContent = (bmfont) => {
  const { version, metadata, info, common, pages, chars, kernings } = bmfont

  // Generate charset description based on actual character IDs
  const generateCharset = () => {
    if (chars.list.length === 0) return '""'

    const sortedIds = chars.list.map((char) => char.id).sort((a, b) => a - b)
    const ranges: string[] = []
    let rangeStart = sortedIds[0]
    let rangeEnd = sortedIds[0]

    for (let i = 1; i < sortedIds.length; i++) {
      if (sortedIds[i] === rangeEnd + 1) {
        rangeEnd = sortedIds[i]
      } else {
        ranges.push(
          rangeStart === rangeEnd
            ? `${rangeStart}`
            : `${rangeStart}-${rangeEnd}`,
        )
        rangeStart = rangeEnd = sortedIds[i]
      }
    }
    ranges.push(
      rangeStart === rangeEnd ? `${rangeStart}` : `${rangeStart}-${rangeEnd}`,
    )

    return `"${ranges.join(',')}"`
  }

  let str = ''

  // Add comprehensive metadata header
  if (metadata) {
    str += `# =============================================================================\n`
    str += `# AngelCode Bitmap Font Generator configuration file\n`
    str += `# =============================================================================\n`
    str += `# Generator: ${metadata.generatorName} v${metadata.generatorVersion}\n`
    str += `# Website: ${metadata.generatorUrl}\n`
    str += `# Generated: ${metadata.generatedAt}\n`
    str += `# BMFont Format Version: ${metadata.formatVersion}\n`
    str += `#\n`
    str += `# Font Information:\n`
    str += `#   Family: ${metadata.fontFamily}\n`
    str += `#   Size: ${metadata.fontSize}px\n`
    str += `#   Padding: ${metadata.padding}px\n`
    str += `#   Spacing: ${metadata.spacing}px\n`
    str += `#\n`
    str += `# Statistics:\n`
    str += `#   Characters: ${metadata.characterCount}\n`
    str += `#   Kerning Pairs: ${metadata.kerningPairCount}\n`
    str += `# =============================================================================\n\n`
  } else if (version) {
    // Fallback to simple header if metadata is not available
    str += `# AngelCode Bitmap Font Generator configuration file\n`
    str += `# Format version: ${version}\n`
    str += `# Generated by SnowBamboo BMF\n\n`
  }

  str += formatStr(TEMP_INFO, {
    ...info,
    charset: info.charset || generateCharset(),
  })

  str += formatStr(TEMP_COMMON, common)

  pages.forEach((p) => {
    str += formatStr(TEMP_PAGE, p)
  })

  str += formatStr(TEMP_CHARS, chars)

  chars.list.forEach((char) => {
    str += formatStr(TEMP_CHAR, char)
  })

  if (kernings.count) {
    str += formatStr(TEMP_KERNINGS, kernings)

    kernings.list.forEach((kerning) => {
      str += formatStr(TEMP_KERNING, kerning)
    })
  }

  return str
}

const outputConfig: Output = { type, exts, getContent }

export default outputConfig
