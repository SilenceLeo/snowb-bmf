{"version":3,"file":"static/js/AutoPacker.6ef5c224b55514fa3efe.worker.js","mappings":"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","sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/rectangle-packer/src/rectanglePacker.ts","../node_modules/rectangle-packer/src/Rect.ts","../node_modules/rectangle-packer/src/GuillotineBinPack.ts","workers/AutoPacker.worker.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","const SUCCESS = 1;\nconst FAIL = 0;\n\n/**\n * 放置状态枚举\n */\nenum TheState {\n    DO_PLACING,\n    DEC_WIDTH,\n    INC_HEIGHT,\n    STOP,\n}\n\n/**\n * 矩形接口\n */\nexport interface Rectangle {\n    width: number;\n    height: number;\n    x?: number;\n    y?: number;\n    __id?: number;\n}\n\n/**\n * 包围区域\n */\nexport interface RectangleSize {\n    width: number;\n    height: number;\n}\n\n/**\n * Cell 是一个链接结构，保存有关单元格的信息\n * height - 单元格的高度\n * occupied - 如果单元格已被占用，则该值将为非零\n * nextCell - 当前单元格正下方的下一个单元格\n */\ninterface ICell {\n    height: number;\n    occupied: number;\n    nextCell: ICell | null;\n}\n\n/**\n * Col 是一个链接结构，保存有关列的信息\n * width - 列宽\n * cell - 指向此列中根单元格的指针（最高的单元格）\n * nextCol - 当前列右边的下一列\n */\ninterface ICol {\n    width: number;\n    cell: ICell | null;\n    nextCol: ICol | null;\n}\n\n/**\n * Placing 将表示放置在矩形表面上的矩形的一个实例\n * enclosingHeight - 包装范围高度，列中所有单元格高度之和\n * enclosingWidth - 包装范围宽度，所有列的宽度之和\n * cols - 指向最左侧的列的指针。\n */\ninterface IPlacing {\n    enclosingHeight: number;\n    enclosingWidth: number;\n    cols: ICol | null;\n}\n\ninterface IRange {\n    startIndex: number;\n    endIndex: number;\n    overshoot: number;\n}\n\ninterface IRegion {\n    colR: IRange;\n    cellR: IRange;\n}\n\nfunction sortForAreaOrHeight(ar: RectangleSize, br: RectangleSize) {\n    const a = ar.width * ar.height;\n    const b = br.width * br.height;\n    if (a < b) {\n        return 1;\n    } else if (a > b) {\n        return -1;\n    } else if (ar.height > br.height) {\n        return -1;\n    } else if (ar.height < br.height) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/**\n * 创建 Placing\n * @param enclosingWidth 区域宽\n * @param enclosingHeight 区域高\n */\nfunction allocPlacing(enclosingWidth: number, enclosingHeight: number): IPlacing {\n    const cell: ICell = {\n        height: enclosingHeight,\n        occupied: 0,\n        nextCell: null,\n    };\n\n    const cols: ICol = {\n        width: enclosingWidth,\n        nextCol: null,\n        cell,\n    };\n\n    const placing: IPlacing = {\n        enclosingWidth,\n        enclosingHeight,\n        cols,\n    };\n\n    return placing;\n}\n\n/**\n * 释放 Placing 对象\n * @param placing 即将释放的 Placing\n */\nfunction freePlacing(placing: IPlacing): void {\n    if (placing === null) {\n        return;\n    }\n    // 循环释放列和单元格\n    let col: ICol | null = placing.cols;\n    while (col !== null) {\n        // 释放列中所有单元格\n        let cell: ICell | null = col.cell;\n        while (cell !== null) {\n            const tempR: ICell = cell;\n            cell = cell.nextCell;\n            tempR.nextCell = null;\n        }\n        // 保存下一个列，释放当前列\n        const tempC: ICol = col;\n        col = col.nextCol;\n        tempC.nextCol = null;\n        tempC.cell = null;\n    }\n    placing.cols = null;\n    return;\n}\n\n/**\n * 尝试调整列高度\n * @param col 列\n * @param height 高度\n * @param cellR 区域\n */\nfunction tryFitHeightInCol(col: ICol, height: number, cellR: IRange): 0 | 1 {\n    /**\n     * 循环列中的单元格\n     * 查找高度大于 height 的连续未被占用的单元格序列。\n     * 结果存储在 cellR 中\n     */\n    if (col == null) {\n        console.error(\"Error. col pointer was null.\\n\");\n        return FAIL;\n    } else if (height <= 0) {\n        console.error(\"Error. height must be positive.\\n\");\n        return FAIL;\n    }\n\n    let sumHeight: number = 0;\n\n    cellR.startIndex = 0;\n    // 循环列中的单元格\n    for (let cell = col.cell, i = 0; cell != null; cell = cell.nextCell, i++) {\n        /**\n         * 如果单元格被占用, 重置高度总和并且更新 startIndex\n         * 否则, 检查高度是否可满足\n         */\n        if (cell.occupied) {\n            sumHeight = 0;\n            cellR.startIndex = i + 1;\n        } else {\n            if (sumHeight + cell.height > height) {\n                cellR.endIndex = i;\n                cellR.overshoot = height - sumHeight;\n                return SUCCESS;\n            } else if (sumHeight + cell.height === height) {\n                // 无需拆分\n                cellR.endIndex = i;\n                cellR.overshoot = 0;\n                return SUCCESS;\n            }\n            sumHeight += cell.height;\n        }\n    }\n    // 如果循环到达这里，说明矩形不适合此列\n    return FAIL;\n}\n\n/**\n * 查找符合偏移的单元格\n * @param base 基础单元格\n * @param offset 偏移量\n */\nfunction stepOffset(base: ICell | null, offset: number): ICell | null {\n    if (base == null) {\n        console.error(\"Error. Basepointer was null.\\n\");\n        return null;\n    }\n\n    let cell: ICell | null = base;\n\n    for (let i = 0; i < offset; i++) {\n        cell = cell.nextCell;\n        if (cell == null) {\n            console.error(\"Error. Offset to large.\\n\");\n            return null;\n        }\n    }\n    return cell;\n}\n\n/**\n * 查找可容纳矩形的区域\n * @param placing 区域\n * @param rectangle 矩形\n * @param reg 位置\n */\nfunction findRegion(placing: IPlacing, rectangle: Rectangle, reg: IRegion): 0 | 1 {\n    // 遍历所有列\n    for (let col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        const colR: IRange = {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        };\n        const cellR: IRange = {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        };\n        let sumWidth: number = 0;\n        let temp: ICol | null;\n\n        // 检查此列是否适合矩形的高度\n        if (!tryFitHeightInCol(col, rectangle.height, cellR)) {\n            // 不合适\n            continue;\n        }\n        // 循环输入列，并检查i的单元格在整个矩形宽度上是否为空\n        colR.startIndex = i;\n        colR.endIndex = i;\n        for (temp = col; temp != null; temp = temp.nextCol) {\n            const cell = stepOffset(temp.cell, cellR.startIndex);\n            if (cell?.occupied) {\n                // 不合适，无法放置\n                break;\n            } else {\n                if (sumWidth + temp.width > rectangle.width) {\n                    // 需要拆分单元格\n                    colR.overshoot = rectangle.width - sumWidth;\n                    reg.colR = colR;\n                    reg.cellR = cellR;\n                    return SUCCESS;\n                } else if (sumWidth + temp.width === rectangle.width) {\n                    // 不需要拆分单元格\n                    colR.overshoot = 0;\n                    reg.colR = colR;\n                    reg.cellR = cellR;\n                    return SUCCESS;\n                }\n                sumWidth += temp.width;\n                colR.endIndex++;\n            }\n        }\n    }\n    return FAIL;\n}\n\nfunction split(placing: IPlacing, reg: IRegion): 0 | 1 {\n    let colSplitMe: ICol | null = null;\n\n    // 水平拆分单元格\n    for (let col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        // 仅 overshoot > 0 时才拆分列\n        if (reg.cellR.overshoot > 0) {\n            const cell = stepOffset(col.cell, reg.cellR.endIndex);\n            if (cell == null) continue;\n            const newCell: ICell = {\n                // 设置新的单元格\n                height: cell.height - reg.cellR.overshoot,\n                occupied: cell.occupied,\n                nextCell: cell.nextCell,\n            };\n            // 更新旧的单元格\n            cell.height = reg.cellR.overshoot;\n            cell.nextCell = newCell;\n        }\n\n        // 保存要拆分的列\n        if (i === reg.colR.endIndex) {\n            colSplitMe = col;\n        }\n    }\n\n    // 仅 overshoot > 0 时才拆分列\n    if (reg.colR.overshoot > 0) {\n        // 纵向拆分列\n        if (colSplitMe == null) {\n            console.log(\"Error. Failed to find column to split.\\n\");\n            return FAIL;\n        }\n\n        const newCol: ICol = {\n            width: colSplitMe.width - reg.colR.overshoot,\n            nextCol: null,\n            cell: {\n                height: 0,\n                occupied: 0,\n                nextCell: null,\n            },\n        };\n\n        // 设置一个新列\n        let tail: ICell = newCol.cell as ICell;\n        for (let cell = colSplitMe.cell; cell != null; cell = cell.nextCell) {\n            tail.height = cell.height;\n            tail.occupied = cell.occupied;\n            if (cell.nextCell == null) {\n                tail.nextCell = null;\n                break;\n            }\n            tail.nextCell = {\n                height: 0,\n                occupied: 0,\n                nextCell: null,\n            };\n            tail = tail.nextCell;\n        }\n        newCol.nextCol = colSplitMe.nextCol;\n\n        // 更新旧的列\n        colSplitMe.width = reg.colR.overshoot;\n        colSplitMe.nextCol = newCol;\n    }\n\n    return SUCCESS;\n}\n\n/**\n * 更新单元格，使其放置在正确的位置\n * @param placing 放置区域\n * @param rectangle 矩形\n * @param reg Region\n */\nfunction update(placing: IPlacing, rectangle: Rectangle, reg: IRegion): 0 | 1 {\n    if (!rectangle.__id || rectangle.__id === 0) {\n        console.error(`Error. Rectangle can't have id = ${rectangle.__id}.\\n`);\n        return FAIL;\n    }\n\n    let x: number = 0;\n    let y: number = 0;\n    let done: number = 0;\n    // 遍历每一列\n    for (let col = placing.cols, i = 0; col != null; col = col.nextCol, i++) {\n        if (i > reg.colR.endIndex) {\n            break;\n        }\n        if (i >= reg.colR.startIndex) {\n            // 遍历单元格\n            for (let cell = col.cell, k = 0; cell != null; cell = cell.nextCell, k++) {\n                if (k > reg.cellR.endIndex) {\n                    break;\n                }\n                if (k >= reg.cellR.startIndex) {\n                    cell.occupied = rectangle.__id;\n                    if (!done) {\n                        rectangle.x = x;\n                        rectangle.y = y;\n                        done = 1;\n                    }\n                }\n                y += cell.height;\n            }\n        }\n        x += col.width;\n    }\n    return SUCCESS;\n}\n\nfunction addRec(p: IPlacing, r: Rectangle): 0 | 1 {\n    const reg: IRegion = {\n        colR: {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        },\n        cellR: {\n            startIndex: 0,\n            endIndex: 0,\n            overshoot: 0,\n        },\n    };\n\n    if (findRegion(p, r, reg) === FAIL) {\n        return FAIL;\n    }\n\n    if (split(p, reg) === FAIL) {\n        console.error(\"Error in splitting.\\n\");\n        return FAIL;\n    }\n\n    if (update(p, r, reg) === FAIL) {\n        console.error(\"Error in updating.\\n\");\n        return FAIL;\n    }\n\n    return SUCCESS;\n}\n\n/**\n * 尝试执行内容排列\n * @param list 矩形列表\n * @param enclosingWidth 容器宽度\n * @param enclosingHeight 容器高度\n */\nfunction doPlacing(list: Rectangle[], enclosingWidth: number, enclosingHeight: number): 0 | 1 {\n    let p: IPlacing | null = allocPlacing(enclosingWidth, enclosingHeight);\n    const len: number = list.length;\n\n    for (let i = 0; i < len; i++) {\n        if (!addRec(p, list[i])) {\n            freePlacing(p);\n            p = null;\n            return FAIL;\n        }\n    }\n    freePlacing(p);\n    p = null;\n    return SUCCESS;\n}\n\n/**\n * 计算所有矩形的宽高和\n * @param list 矩形列表\n */\nfunction sumWH(list: Rectangle[]): RectangleSize {\n    const len = list.length;\n    let width = 0;\n    let height = 0;\n    for (let i = 0; i < len; i++) {\n        width += list[i].width;\n        height += list[i].height;\n    }\n    return {\n        width,\n        height,\n    };\n}\n\n/**\n * 查找所有矩形中，宽度最大值与高度最大值\n * @param list 矩形列表\n */\nfunction maxWH(list: Rectangle[]): RectangleSize {\n    const len = list.length;\n    let width = 0;\n    let height = 0;\n\n    for (let i = 0; i < len; i++) {\n        if (list[i].width >= width) {\n            width = list[i].width;\n        }\n        if (list[i].height >= height) {\n            height = list[i].height;\n        }\n    }\n    return {\n        width,\n        height,\n    };\n}\n\n/**\n * 计算所有矩形总面积\n * @param list 矩形列表\n */\nfunction totalArea(list: Rectangle[]): number {\n    const len = list.length;\n    let area = 0;\n    for (let i = 0; i < len; i++) {\n        area += list[i].height * list[i].width;\n    }\n    return area;\n}\n\n/**\n * 计算容器需要的最大宽度\n * @param list 矩形列表\n */\nfunction placingWidth(list: Rectangle[]): number {\n    const len = list.length;\n    let width = 0;\n    for (let i = 0; i < len; i++) {\n        if (list[i].x === -1) {\n            console.error(\"Error. Can't compute placing_width if not all rectangles have been placed.\\n\");\n            return -1;\n        }\n        if (list[i].width + (list[i].x as number) >= width) {\n            width = list[i].width + (list[i].x as number);\n        }\n    }\n    return width;\n}\n\n/**\n * 放置最小区域算法\n * @param list 矩形列表\n * @param en 初始区域\n */\nfunction areapackAlgorithm(list: Rectangle[], en: RectangleSize): 0 | 1 {\n    const { width: maxWidth, height: maxHeight } = maxWH(list);\n    const { width: sumWidth } = sumWH(list);\n    let minWidth = -1;\n    let minHeight = -1;\n    let area = -1;\n    let status: number;\n    let state: TheState;\n    const totArea = totalArea(list);\n    /* 初始化高度为最大高度 */\n    en.height = maxHeight;\n    en.width = sumWidth;\n\n    area = en.height * en.width;\n    state = TheState.DO_PLACING;\n\n    /* 从封闭区域(w=sum, h=max)开始查找\n     * do placing\n     * - 如果成功，保存区域\n     * - 如果失败，尝试新的封闭区域\n     *\n     * 减小宽度，否则增加高度直到成功\n     *\n     * 如果 en width=max: 停止\n     *\n     * */\n\n    let loop = 1;\n    while (loop) {\n        switch (state) {\n            case TheState.DO_PLACING:\n                /**\n                 * 尝试将矩形放置在封闭矩形中。\n                 * 如果成功，保存该区域，然后尝试减小包装宽度。\n                 * 如果失败，增加高度并重试。\n                 */\n                status = doPlacing(list, en.width, en.height);\n                if (status === 1) {\n                    en.width = placingWidth(list);\n\n                    area = en.height * en.width;\n                    minWidth = en.width;\n                    minHeight = en.height;\n\n                    state = TheState.DEC_WIDTH;\n                } else {\n                    state = TheState.INC_HEIGHT;\n                }\n                break;\n            case TheState.DEC_WIDTH:\n                /**\n                 * 减小包装宽度，然后尝试再次放置。\n                 * 如果新宽度小于矩形的最大宽度，则停止算法并提出最佳解决方案\n                 */\n                en.width--;\n                if (en.width < maxWidth) {\n                    state = TheState.STOP;\n                } else {\n                    state = TheState.DO_PLACING;\n                }\n                break;\n            case TheState.INC_HEIGHT:\n                /**\n                 * 增加封闭高度，然后尝试再次放置。\n                 * 但是，如果新的高度使封闭区域小于所有矩形的总面积，则增加封闭高度并重新开始。\n                 * 如果封闭区域比目前最好的封闭区域大，则减小封闭宽度并重新开始。\n                 */\n                en.height++;\n                if (en.height * en.width < totArea) {\n                    state = TheState.INC_HEIGHT;\n                } else if (en.height * en.width >= area) {\n                    state = TheState.DEC_WIDTH;\n                } else {\n                    state = TheState.DO_PLACING;\n                }\n                break;\n            case TheState.STOP:\n                // 计算结束\n                loop = 0;\n                break;\n        }\n    }\n    if (minWidth === -1 || minHeight === -1) {\n        return FAIL;\n    }\n    // 以最佳的宽度和高度进行最后放置\n    status = doPlacing(list, minWidth, minHeight);\n\n    return SUCCESS;\n}\n\n/**\n * 打包给到的所有矩形\n * @param rectangleSizes 带有宽高的矩形列表\n */\nexport function rectanglePacker<T extends RectangleSize>(rectangleSizes: T[]): Rectangle[] {\n    if (!Array.isArray(rectangleSizes) || rectangleSizes.length === 0) return [];\n\n    const enclosing: Rectangle = { width: 0, height: 0 };\n\n    const rectList = rectangleSizes.map(({ width, height }, i) => {\n        if (!width || !height) throw new Error(\"Rectangle width and height must be an integer\");\n        return {\n            width,\n            height,\n            x: -1,\n            y: -1,\n            __id: i + 1,\n        };\n    });\n\n    const result = areapackAlgorithm(rectList, enclosing);\n\n    if (result === FAIL) {\n        console.error(\"Unexpected error in algorithm implementation\");\n        return [];\n    }\n\n    rectList.forEach((rectangle) => delete rectangle.__id);\n\n    return rectList;\n}\n\nexport function rectanglePackerMutation<T extends Rectangle>(rectangleSizes: T[]): (T & Rectangle)[] {\n    const list = rectanglePacker(rectangleSizes);\n\n    rectangleSizes.forEach((rs, i) => {\n        rs.x = list[i].x;\n        rs.y = list[i].y;\n    });\n\n    return rectangleSizes;\n}\n","export interface RectSize {\n    width: number\n    height: number\n  }\n  \n  export default class Rect {\n    constructor(\n      public x: number = 0,\n      public y: number = 0,\n      public width: number = 0,\n      public height: number = 0,\n    ) {}\n  \n    static IsContainedIn(a: Rect, b: Rect) {\n      return (\n        a.x >= b.x &&\n        a.y >= b.y &&\n        a.x + a.width <= b.x + b.width &&\n        a.y + a.height <= b.y + b.height\n      )\n    }\n  }\n  ","import Rect, { RectSize } from \"./Rect\";\n\ninterface RefNumber {\n    value: number;\n}\n/// Specifies the different choice heuristics that can be used when deciding which of the free subrectangles\n/// to place the to-be-packed rectangle into.\nenum FreeRectChoiceHeuristic {\n    RectBestAreaFit, ///< -BAF\n    RectBestShortSideFit, ///< -BSSF\n    RectBestLongSideFit, ///< -BLSF\n    RectWorstAreaFit, ///< -WAF\n    RectWorstShortSideFit, ///< -WSSF\n    RectWorstLongSideFit, ///< -WLSF\n}\n\n/// Specifies the different choice heuristics that can be used when the packer needs to decide whether to\n/// subdivide the remaining free space in horizontal or vertical direction.\nenum GuillotineSplitHeuristic {\n    SplitShorterLeftoverAxis, ///< -SLAS\n    SplitLongerLeftoverAxis, ///< -LLAS\n    SplitMinimizeArea, ///< -MINAS, Try to make a single big rectangle at the expense of making the other small.\n    SplitMaximizeArea, ///< -MAXAS, Try to make both remaining rectangles as even-sized as possible.\n    SplitShorterAxis, ///< -SAS\n    SplitLongerAxis, ///< -LAS\n}\n\nexport default class GuillotineBinPack<T extends Rect> {\n    public usedRectangles: T[] = [];\n    public freeRectangles: Rect[] = [];\n    static FreeRectChoiceHeuristic = FreeRectChoiceHeuristic;\n    static GuillotineSplitHeuristic = GuillotineSplitHeuristic;\n    constructor(public binWidth: number = 0, public binHeight: number = 0, public allowFlip: boolean = false) {\n        if (this.binWidth && this.binHeight) {\n            this.freeRectangles.push(new Rect(0, 0, this.binWidth, this.binHeight));\n        }\n    }\n\n    InsertSizes(\n        rects: T[],\n        merge: boolean,\n        rectChoice: FreeRectChoiceHeuristic,\n        splitMethod: GuillotineSplitHeuristic\n    ): void {\n        // Remember variables about the best packing choice we have made so far during the iteration process.\n        let bestFreeRect = 0;\n        let bestRect = 0;\n        let bestFlipped = false;\n\n        // Pack rectangles one at a time until we have cleared the rects array of all rectangles.\n        // rects will get destroyed in the process.\n        while (rects.length > 0) {\n            // Stores the penalty score of the best rectangle placement - bigger=worse, smaller=better.\n            let bestScore = Number.MAX_VALUE;\n\n            for (let i = 0; i < this.freeRectangles.length; ++i) {\n                for (let j = 0; j < rects.length; ++j) {\n                    // If this rectangle is a perfect match, we pick it instantly.\n                    if (\n                        rects[j].width === this.freeRectangles[i].width &&\n                        rects[j].height === this.freeRectangles[i].height\n                    ) {\n                        bestFreeRect = i;\n                        bestRect = j;\n                        bestFlipped = false;\n                        bestScore = Number.MIN_VALUE;\n                        i = this.freeRectangles.length; // Force a jump out of the outer loop as well - we got an instant fit.\n                        break;\n                    }\n                    // If flipping this rectangle is a perfect match, pick that then.\n                    else if (\n                        this.allowFlip &&\n                        rects[j].height === this.freeRectangles[i].width &&\n                        rects[j].width === this.freeRectangles[i].height\n                    ) {\n                        bestFreeRect = i;\n                        bestRect = j;\n                        bestFlipped = true;\n                        bestScore = Number.MIN_VALUE;\n                        i = this.freeRectangles.length; // Force a jump out of the outer loop as well - we got an instant fit.\n                        break;\n                    }\n                    // Try if we can fit the rectangle upright.\n                    else if (\n                        rects[j].width <= this.freeRectangles[i].width &&\n                        rects[j].height <= this.freeRectangles[i].height\n                    ) {\n                        let score = this.ScoreByHeuristic(\n                            rects[j].width,\n                            rects[j].height,\n                            this.freeRectangles[i],\n                            rectChoice\n                        );\n                        if (score < bestScore) {\n                            bestFreeRect = i;\n                            bestRect = j;\n                            bestFlipped = false;\n                            bestScore = score;\n                        }\n                    }\n                    // If not, then perhaps flipping sideways will make it fit?\n                    else if (\n                        this.allowFlip &&\n                        rects[j].height <= this.freeRectangles[i].width &&\n                        rects[j].width <= this.freeRectangles[i].height\n                    ) {\n                        let score = this.ScoreByHeuristic(\n                            rects[j].height,\n                            rects[j].width,\n                            this.freeRectangles[i],\n                            rectChoice\n                        );\n                        if (score < bestScore) {\n                            bestFreeRect = i;\n                            bestRect = j;\n                            bestFlipped = true;\n                            bestScore = score;\n                        }\n                    }\n                }\n            }\n\n            // If we didn't manage to find any rectangle to pack, abort.\n            if (bestScore === Number.MAX_VALUE) return;\n\n            // Remove the rectangle we just packed from the input list.\n            const [node] = rects.splice(bestRect, 1);\n\n            node.x = this.freeRectangles[bestFreeRect].x;\n            node.y = this.freeRectangles[bestFreeRect].y;\n\n            // Otherwise, we're good to go and do the actual packing.\n            const newNode = new Rect(\n                this.freeRectangles[bestFreeRect].x,\n                this.freeRectangles[bestFreeRect].y,\n                node.width,\n                node.height\n            );\n\n            if (bestFlipped) [newNode.width, newNode.height] = [newNode.height, newNode.width];\n\n            // Remove the free space we lost in the bin.\n            this.SplitFreeRectByHeuristic(this.freeRectangles[bestFreeRect], newNode, splitMethod);\n            this.freeRectangles.splice(bestFreeRect, 1);\n\n            // Perform a Rectangle Merge step if desired.\n            if (merge) this.MergeFreeList();\n\n            // Remember the new used rectangle.\n            this.usedRectangles.push(node);\n\n            // Check that we're really producing correct packings here.\n            // debug_assert(disjointRects.Add(newNode) === true);\n        }\n    }\n\n    /// @return True if r fits inside freeRect (possibly rotated).\n    Fits(r: RectSize, freeRect: Rect): boolean {\n        return (\n            (r.width <= freeRect.width && r.height <= freeRect.height) ||\n            (r.height <= freeRect.width && r.width <= freeRect.height)\n        );\n    }\n\n    /// @return True if r fits perfectly inside freeRect, i.e. the leftover area is 0.\n    FitsPerfectly(r: RectSize, freeRect: Rect): boolean {\n        return (\n            (r.width === freeRect.width && r.height === freeRect.height) ||\n            (r.height === freeRect.width && r.width === freeRect.height)\n        );\n    }\n\n    //   Insert(\n    //     width: number,\n    //     height: number,\n    //     merge: boolean,\n    //     rectChoice: FreeRectChoiceHeuristic,\n    //     splitMethod: GuillotineSplitHeuristic,\n    //   ): Rect {\n    //     // Find where to put the new rectangle.\n    //     let freeNodeIndex: RefNumber = { value: 0 }\n    //     const newRect: Rect = this.FindPositionForNewNode(\n    //       width,\n    //       height,\n    //       rectChoice,\n    //       freeNodeIndex,\n    //     )\n\n    //     // Abort if we didn't have enough space in the bin.\n    //     if (newRect.height === 0) return newRect\n\n    //     // Remove the space that was just consumed by the new rectangle.\n    //     this.SplitFreeRectByHeuristic(\n    //       this.freeRectangles[freeNodeIndex.value],\n    //       newRect,\n    //       splitMethod,\n    //     )\n    //     this.freeRectangles.splice(freeNodeIndex.value, 1)\n\n    //     // Perform a Rectangle Merge step if desired.\n    //     if (merge) this.MergeFreeList()\n\n    //     // Remember the new used rectangle.\n    //     this.usedRectangles.push(newRect)\n\n    //     // Check that we're really producing correct packings here.\n    //     // debug_assert(disjointRects.Add(newRect) === true);\n\n    //     return newRect\n    //   }\n\n    /// Computes the ratio of used surface area to the total bin area.\n    Occupancy(): number {\n        ///\\todo The occupancy rate could be cached/tracked incrementally instead\n        ///      of looping through the list of packed rectangles here.\n        let usedSurfaceArea = 0;\n        for (let i = 0; i < this.usedRectangles.length; ++i)\n            usedSurfaceArea += this.usedRectangles[i].width * this.usedRectangles[i].height;\n\n        return usedSurfaceArea / (this.binWidth * this.binHeight);\n    }\n\n    /// Returns the heuristic score value for placing a rectangle of size width*height into freeRect. Does not try to rotate.\n    ScoreByHeuristic(width: number, height: number, freeRect: Rect, rectChoice: FreeRectChoiceHeuristic): number {\n        switch (rectChoice) {\n            case FreeRectChoiceHeuristic.RectBestAreaFit:\n                return this.ScoreBestAreaFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectBestShortSideFit:\n                return this.ScoreBestShortSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectBestLongSideFit:\n                return this.ScoreBestLongSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstAreaFit:\n                return this.ScoreWorstAreaFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstShortSideFit:\n                return this.ScoreWorstShortSideFit(width, height, freeRect);\n            case FreeRectChoiceHeuristic.RectWorstLongSideFit:\n                return this.ScoreWorstLongSideFit(width, height, freeRect);\n            default:\n                return Number.MAX_VALUE;\n        }\n    }\n\n    ScoreBestAreaFit(width: number, height: number, freeRect: Rect): number {\n        return freeRect.width * freeRect.height - width * height;\n    }\n\n    ScoreBestShortSideFit(width: number, height: number, freeRect: Rect): number {\n        const leftoverHoriz = Math.abs(freeRect.width - width);\n        const leftoverVert = Math.abs(freeRect.height - height);\n        const leftover = Math.min(leftoverHoriz, leftoverVert);\n        return leftover;\n    }\n\n    ScoreBestLongSideFit(width: number, height: number, freeRect: Rect): number {\n        const leftoverHoriz = Math.abs(freeRect.width - width);\n        const leftoverVert = Math.abs(freeRect.height - height);\n        const leftover = Math.max(leftoverHoriz, leftoverVert);\n        return leftover;\n    }\n\n    ScoreWorstAreaFit(width: number, height: number, freeRect: Rect) {\n        return -this.ScoreBestAreaFit(width, height, freeRect);\n    }\n\n    ScoreWorstShortSideFit(width: number, height: number, freeRect: Rect) {\n        return -this.ScoreBestShortSideFit(width, height, freeRect);\n    }\n\n    ScoreWorstLongSideFit(width: number, height: number, freeRect: Rect): number {\n        return -this.ScoreBestLongSideFit(width, height, freeRect);\n    }\n\n    FindPositionForNewNode(\n        width: number,\n        height: number,\n        rectChoice: FreeRectChoiceHeuristic,\n        nodeIndex: RefNumber\n    ): Rect {\n        let bestNode: Rect = new Rect();\n\n        let bestScore = Number.MAX_VALUE;\n\n        /// Try each free rectangle to find the best one for placement.\n        for (let i = 0; i < this.freeRectangles.length; ++i) {\n            // If this is a perfect fit upright, choose it immediately.\n            if (width === this.freeRectangles[i].width && height === this.freeRectangles[i].height) {\n                bestNode.x = this.freeRectangles[i].x;\n                bestNode.y = this.freeRectangles[i].y;\n                bestNode.width = width;\n                bestNode.height = height;\n                bestScore = Number.MIN_VALUE;\n                nodeIndex.value = i;\n                // debug_assert(disjointRects.Disjoint(bestNode));\n                break;\n            }\n            // If this is a perfect fit sideways, choose it.\n            else if (height === this.freeRectangles[i].width && width === this.freeRectangles[i].height) {\n                bestNode.x = this.freeRectangles[i].x;\n                bestNode.y = this.freeRectangles[i].y;\n                bestNode.width = height;\n                bestNode.height = width;\n                bestScore = Number.MIN_VALUE;\n                nodeIndex.value = i;\n                // debug_assert(disjointRects.Disjoint(bestNode));\n                break;\n            }\n            // Does the rectangle fit upright?\n            else if (width <= this.freeRectangles[i].width && height <= this.freeRectangles[i].height) {\n                let score = this.ScoreByHeuristic(width, height, this.freeRectangles[i], rectChoice);\n\n                if (score < bestScore) {\n                    bestNode.x = this.freeRectangles[i].x;\n                    bestNode.y = this.freeRectangles[i].y;\n                    bestNode.width = width;\n                    bestNode.height = height;\n                    bestScore = score;\n                    nodeIndex.value = i;\n                    // debug_assert(disjointRects.Disjoint(bestNode));\n                }\n            }\n            // Does the rectangle fit sideways?\n            else if (height <= this.freeRectangles[i].width && width <= this.freeRectangles[i].height) {\n                let score = this.ScoreByHeuristic(height, width, this.freeRectangles[i], rectChoice);\n\n                if (score < bestScore) {\n                    bestNode.x = this.freeRectangles[i].x;\n                    bestNode.y = this.freeRectangles[i].y;\n                    bestNode.width = height;\n                    bestNode.height = width;\n                    bestScore = score;\n                    nodeIndex.value = i;\n                    // debug_assert(disjointRects.Disjoint(bestNode));\n                }\n            }\n        }\n        return bestNode;\n    }\n\n    SplitFreeRectByHeuristic(freeRect: Rect, placedRect: Rect, method: GuillotineSplitHeuristic): void {\n        // Compute the lengths of the leftover area.\n        const w = freeRect.width - placedRect.width;\n        const h = freeRect.height - placedRect.height;\n\n        // Placing placedRect into freeRect results in an L-shaped free area, which must be split into\n        // two disjoint rectangles. This can be achieved with by splitting the L-shape using a single line.\n        // We have two choices: horizontal or vertical.\n\n        // Use the given heuristic to decide which choice to make.\n\n        let splitHorizontal: boolean;\n        switch (method) {\n            case GuillotineSplitHeuristic.SplitShorterLeftoverAxis:\n                // Split along the shorter leftover axis.\n                splitHorizontal = w <= h;\n                break;\n            case GuillotineSplitHeuristic.SplitLongerLeftoverAxis:\n                // Split along the longer leftover axis.\n                splitHorizontal = w > h;\n                break;\n            case GuillotineSplitHeuristic.SplitMinimizeArea:\n                // Maximize the larger area === minimize the smaller area.\n                // Tries to make the single bigger rectangle.\n                splitHorizontal = placedRect.width * h > w * placedRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitMaximizeArea:\n                // Maximize the smaller area === minimize the larger area.\n                // Tries to make the rectangles more even-sized.\n                splitHorizontal = placedRect.width * h <= w * placedRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitShorterAxis:\n                // Split along the shorter total axis.\n                splitHorizontal = freeRect.width <= freeRect.height;\n                break;\n            case GuillotineSplitHeuristic.SplitLongerAxis:\n                // Split along the longer total axis.\n                splitHorizontal = freeRect.width > freeRect.height;\n                break;\n            default:\n                splitHorizontal = true;\n            // assert(false);\n        }\n\n        // Perform the actual split.\n        this.SplitFreeRectAlongAxis(freeRect, placedRect, splitHorizontal);\n    }\n\n    /// This function will add the two generated rectangles into the this.freeRectangles array. The caller is expected to\n    /// remove the original rectangle from the this.freeRectangles array after that.\n    SplitFreeRectAlongAxis(freeRect: Rect, placedRect: Rect, splitHorizontal: boolean): void {\n        // Form the two new rectangles.\n        const bottom: Rect = new Rect(\n            freeRect.x,\n            freeRect.y + placedRect.height,\n            0,\n            freeRect.height - placedRect.height\n        );\n\n        const right: Rect = new Rect(freeRect.x + placedRect.width, freeRect.y, freeRect.width - placedRect.width, 0);\n\n        if (splitHorizontal) {\n            bottom.width = freeRect.width;\n            right.height = placedRect.height;\n        } // Split vertically\n        else {\n            bottom.width = placedRect.width;\n            right.height = freeRect.height;\n        }\n\n        // Add the new rectangles into the free rectangle pool if they weren't degenerate.\n        if (bottom.width > 0 && bottom.height > 0) this.freeRectangles.push(bottom);\n        if (right.width > 0 && right.height > 0) this.freeRectangles.push(right);\n\n        // debug_assert(disjointRects.Disjoint(bottom));\n        // debug_assert(disjointRects.Disjoint(right));\n    }\n\n    MergeFreeList(): void {\n        // Do a Theta(n^2) loop to see if any pair of free rectangles could me merged into one.\n        // Note that we miss any opportunities to merge three rectangles into one. (should call this function again to detect that)\n        for (let i = 0; i < this.freeRectangles.length; ++i)\n            for (let j = i + 1; j < this.freeRectangles.length; ++j) {\n                if (\n                    this.freeRectangles[i].width === this.freeRectangles[j].width &&\n                    this.freeRectangles[i].x === this.freeRectangles[j].x\n                ) {\n                    if (this.freeRectangles[i].y === this.freeRectangles[j].y + this.freeRectangles[j].height) {\n                        this.freeRectangles[i].y -= this.freeRectangles[j].height;\n                        this.freeRectangles[i].height += this.freeRectangles[j].height;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    } else if (this.freeRectangles[i].y + this.freeRectangles[i].height === this.freeRectangles[j].y) {\n                        this.freeRectangles[i].height += this.freeRectangles[j].height;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                } else if (\n                    this.freeRectangles[i].height === this.freeRectangles[j].height &&\n                    this.freeRectangles[i].y === this.freeRectangles[j].y\n                ) {\n                    if (this.freeRectangles[i].x === this.freeRectangles[j].x + this.freeRectangles[j].width) {\n                        this.freeRectangles[i].x -= this.freeRectangles[j].width;\n                        this.freeRectangles[i].width += this.freeRectangles[j].width;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    } else if (this.freeRectangles[i].x + this.freeRectangles[i].width === this.freeRectangles[j].x) {\n                        this.freeRectangles[i].width += this.freeRectangles[j].width;\n                        this.freeRectangles.splice(j, 1);\n                        --j;\n                    }\n                }\n            }\n    }\n}\n","import { GuillotineBinPack } from 'rectangle-packer'\n\ninterface Rectangle {\n  width: number\n  height: number\n  x: number\n  y: number\n  letter: string\n}\n\nfunction maxMin(list: Rectangle[]) {\n  const widthList = list.map((item) => item.width)\n  const heightList = list.map((item) => item.height)\n  return {\n    minWidth: Math.min.apply(null, widthList),\n    minHeight: Math.min.apply(null, heightList),\n    maxWidth: widthList.reduce((a, b) => a + b, 0),\n    maxHeight: heightList.reduce((a, b) => a + b, 0),\n  }\n}\n\nfunction packing(list: Rectangle[]) {\n  const sizes = maxMin(list)\n  let min = Math.max(sizes.minWidth, sizes.minHeight)\n  let max = Math.max(sizes.maxWidth, sizes.maxHeight)\n  let state = 1\n  let placed: Rectangle[] = []\n  while (state) {\n    const size = min + Math.ceil((max - min) / 2)\n    const packer = new GuillotineBinPack<Rectangle>(size, size)\n    packer.InsertSizes([...list], true, 1, 1)\n\n    if (max - min < 2) {\n      state = 0\n    } else if (list.length > packer.usedRectangles.length) {\n      min += Math.ceil((max - min) / 2)\n    } else {\n      placed = packer.usedRectangles\n      max -= Math.floor((max - min) / 2)\n    }\n  }\n  return placed\n}\n\n// eslint-disable-next-line no-restricted-globals\nconst ctx: Worker = self as unknown as Worker\nctx.addEventListener(\n  'message',\n  function converter(msg) {\n    const { data } = msg\n    if (data.length > 1) {\n      const list = packing(data as Rectangle[])\n      ctx.postMessage(list)\n    } else {\n      ctx.postMessage(data || [])\n    }\n  },\n  false,\n)\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_toConsumableArray","isArray","iter","Symbol","iterator","from","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","test","TypeError","TheState","FreeRectChoiceHeuristic","GuillotineSplitHeuristic","Rect","x","y","width","height","IsContainedIn","a","b","GuillotineBinPack","binWidth","binHeight","allowFlip","usedRectangles","freeRectangles","this","push","InsertSizes","rects","merge","rectChoice","splitMethod","bestFreeRect","bestRect","bestFlipped","bestScore","Number","MAX_VALUE","j","MIN_VALUE","score","ScoreByHeuristic","node","splice","newNode","_a","SplitFreeRectByHeuristic","MergeFreeList","Fits","r","freeRect","FitsPerfectly","Occupancy","usedSurfaceArea","RectBestAreaFit","ScoreBestAreaFit","RectBestShortSideFit","ScoreBestShortSideFit","RectBestLongSideFit","ScoreBestLongSideFit","RectWorstAreaFit","ScoreWorstAreaFit","RectWorstShortSideFit","ScoreWorstShortSideFit","RectWorstLongSideFit","ScoreWorstLongSideFit","leftoverHoriz","Math","abs","leftoverVert","min","max","FindPositionForNewNode","nodeIndex","bestNode","value","placedRect","method","splitHorizontal","w","h","SplitShorterLeftoverAxis","SplitLongerLeftoverAxis","SplitMinimizeArea","SplitMaximizeArea","SplitShorterAxis","SplitLongerAxis","SplitFreeRectAlongAxis","bottom","right","packing","list","sizes","widthList","map","item","heightList","minWidth","apply","minHeight","maxWidth","reduce","maxHeight","maxMin","state","placed","size","ceil","packer","floor","ctx","self","addEventListener","msg","data","postMessage"],"sourceRoot":""}